---
import BaseLayout from "../../layouts/BaseLayout.astro";
import { directusFetchItems } from "../../lib/directus";
import { getDownloadPlatform } from "../../lib/download-link";
import { GENRE_SUPERSETS, normalizeGenreSlugs } from "../../lib/genre-supersets";
import { formatUnknown } from "../../lib/list-format";

const engines = await directusFetchItems("engines", {
  fields: ["slug", "title"],
  sort: ["title"],
  limit: 500,
});
const genres = await directusFetchItems("genres", {
  fields: ["slug", "name"],
  sort: ["name"],
  limit: 500,
});
const developers = await directusFetchItems("developers", {
  fields: ["slug", "name"],
  sort: ["name"],
  limit: 500,
});
const tierLists = await directusFetchItems("tier_lists", {
  fields: ["id", "title", "status"],
  limit: 500,
});
const games = await directusFetchItems("games", {
  fields: [
    "id",
    "game_status",
    "player_status",
    "download_url",
    "gamestorylog_url",
    "engines.engines_id.slug",
    "genres.genres_id.slug",
    "developers.developers_id.slug",
  ],
  limit: 1000,
});

const engineLabel = new Map();
for (const engine of engines ?? []) {
  if (engine?.slug) engineLabel.set(engine.slug, engine.title ?? engine.slug);
}
const genreLabel = new Map();
for (const genre of genres ?? []) {
  if (genre?.slug) genreLabel.set(genre.slug, genre.name ?? genre.slug);
}
const developerLabel = new Map();
for (const developer of developers ?? []) {
  if (developer?.slug) {
    developerLabel.set(developer.slug, developer.name ?? developer.slug);
  }
}

const engineGenreCounts = new Map();
const engineGenreTotalCounts = new Map();
const engineStatusCounts = new Map();
const engineStatusValues = new Map();
const developerStatusCounts = new Map();
const developerStatusValues = new Map();
const genreStatusCounts = new Map();
const genreStatusTotalCounts = new Map();
const genreStatusValues = new Map();
const enginePlayedCounts = new Map();
const enginePlayedValues = new Map();
const developerPlayedCounts = new Map();
const developerPlayedValues = new Map();
const genrePlayedCounts = new Map();
const genrePlayedTotalCounts = new Map();
const genrePlayedValues = new Map();

for (const game of games ?? []) {
  const engineSlugs =
    (game.engines ?? []).map((entry) => entry?.engines_id?.slug).filter(Boolean);
  const rawGenreSlugs =
    (game.genres ?? []).map((entry) => entry?.genres_id?.slug).filter(Boolean);
  const distinctGenreSlugs = normalizeGenreSlugs(rawGenreSlugs);
  const developerSlugs =
    (game.developers ?? []).map((entry) => entry?.developers_id?.slug).filter(Boolean);

  const enginesForGame = engineSlugs.length ? engineSlugs : ["unknown"];
  const totalGenresForGame = rawGenreSlugs.length ? rawGenreSlugs : ["unknown"];
  const distinctGenresForGame = distinctGenreSlugs.length ? distinctGenreSlugs : ["unknown"];
  const developersForGame = developerSlugs.length ? developerSlugs : ["unknown"];

  for (const engine of enginesForGame) {
    for (const genre of distinctGenresForGame) {
      const key = `${engine}::${genre}`;
      engineGenreCounts.set(key, (engineGenreCounts.get(key) || 0) + 1);
    }
  }
  for (const engine of enginesForGame) {
    for (const genre of totalGenresForGame) {
      const key = `${engine}::${genre}`;
      engineGenreTotalCounts.set(key, (engineGenreTotalCounts.get(key) || 0) + 1);
    }
  }

  if (game.game_status) {
    for (const engine of enginesForGame) {
      const key = `${engine}::${game.game_status}`;
      engineStatusCounts.set(key, (engineStatusCounts.get(key) || 0) + 1);
      if (!engineStatusValues.has(engine)) {
        engineStatusValues.set(engine, new Set());
      }
      engineStatusValues.get(engine).add(game.game_status);
    }
    for (const developer of developersForGame) {
      const key = `${developer}::${game.game_status}`;
      developerStatusCounts.set(key, (developerStatusCounts.get(key) || 0) + 1);
      if (!developerStatusValues.has(developer)) {
        developerStatusValues.set(developer, new Set());
      }
      developerStatusValues.get(developer).add(game.game_status);
    }
    for (const genre of distinctGenresForGame) {
      const key = `${genre}::${game.game_status}`;
      genreStatusCounts.set(key, (genreStatusCounts.get(key) || 0) + 1);
      if (!genreStatusValues.has(genre)) {
        genreStatusValues.set(genre, new Set());
      }
      genreStatusValues.get(genre).add(game.game_status);
    }
    for (const genre of totalGenresForGame) {
      const key = `${genre}::${game.game_status}`;
      genreStatusTotalCounts.set(key, (genreStatusTotalCounts.get(key) || 0) + 1);
    }
  }

  if (game.player_status) {
    for (const engine of enginesForGame) {
      const key = `${engine}::${game.player_status}`;
      enginePlayedCounts.set(key, (enginePlayedCounts.get(key) || 0) + 1);
      if (!enginePlayedValues.has(engine)) {
        enginePlayedValues.set(engine, new Set());
      }
      enginePlayedValues.get(engine).add(game.player_status);
    }
    for (const developer of developersForGame) {
      const key = `${developer}::${game.player_status}`;
      developerPlayedCounts.set(key, (developerPlayedCounts.get(key) || 0) + 1);
      if (!developerPlayedValues.has(developer)) {
        developerPlayedValues.set(developer, new Set());
      }
      developerPlayedValues.get(developer).add(game.player_status);
    }
    for (const genre of distinctGenresForGame) {
      const key = `${genre}::${game.player_status}`;
      genrePlayedCounts.set(key, (genrePlayedCounts.get(key) || 0) + 1);
      if (!genrePlayedValues.has(genre)) {
        genrePlayedValues.set(genre, new Set());
      }
      genrePlayedValues.get(genre).add(game.player_status);
    }
    for (const genre of totalGenresForGame) {
      const key = `${genre}::${game.player_status}`;
      genrePlayedTotalCounts.set(key, (genrePlayedTotalCounts.get(key) || 0) + 1);
    }
  }
}

const labelize = (value) =>
  value ? value.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase()) : "";
const unknownLast = (a, b, key) => {
  const aUnknown = a[key]?.startsWith("<Unknown ");
  const bUnknown = b[key]?.startsWith("<Unknown ");
  if (aUnknown !== bUnknown) return aUnknown ? 1 : -1;
  return 0;
};
const isSupersetGenre = (slug) =>
  Object.prototype.hasOwnProperty.call(GENRE_SUPERSETS, slug);

const engineGenreEntries = Array.from(engineGenreTotalCounts.entries())
  .map(([key, totalCount]) => {
    const [engine, genre] = key.split("::");
    return {
      engine,
      genre,
      count: engineGenreCounts.get(key) || 0,
      totalCount,
      engineLabel: engineLabel.get(engine) ?? formatUnknown(engine, "Engine"),
      genreLabel: genreLabel.get(genre) ?? formatUnknown(genre, "Genre"),
    };
  })
  .filter((entry) => !(isSupersetGenre(entry.genre) && entry.count === 0))
  .sort((a, b) =>
    unknownLast(a, b, "engineLabel") ||
    a.engineLabel.localeCompare(b.engineLabel) ||
    unknownLast(a, b, "genreLabel") ||
    a.genreLabel.localeCompare(b.genreLabel));


const engineStatusEntries = Array.from(engineStatusCounts.entries())
  .map(([key, count]) => {
    const [engine, status] = key.split("::");
    return {
      engine,
      status,
      count,
      engineLabel: engineLabel.get(engine) ?? formatUnknown(engine, "Engine"),
      statusLabel: labelize(status),
    };
  })
  .filter((entry) => (engineStatusValues.get(entry.engine)?.size ?? 0) > 1)
  .sort((a, b) =>
    unknownLast(a, b, "engineLabel") ||
    a.engineLabel.localeCompare(b.engineLabel) ||
    a.statusLabel.localeCompare(b.statusLabel));

const developerStatusEntries = Array.from(developerStatusCounts.entries())
  .map(([key, count]) => {
    const [developer, status] = key.split("::");
    return {
      developer,
      status,
      count,
      developerLabel: developerLabel.get(developer) ?? formatUnknown(developer, "Developer"),
      statusLabel: labelize(status),
    };
  })
  .filter((entry) => (developerStatusValues.get(entry.developer)?.size ?? 0) > 1)
  .sort((a, b) =>
    unknownLast(a, b, "developerLabel") ||
    a.developerLabel.localeCompare(b.developerLabel) ||
    a.statusLabel.localeCompare(b.statusLabel));

const genreStatusEntries = Array.from(genreStatusTotalCounts.entries())
  .map(([key, totalCount]) => {
    const [genre, status] = key.split("::");
    return {
      genre,
      status,
      count: genreStatusCounts.get(key) || 0,
      totalCount,
      genreLabel: genreLabel.get(genre) ?? formatUnknown(genre, "Genre"),
      statusLabel: labelize(status),
    };
  })
  .filter((entry) => (genreStatusValues.get(entry.genre)?.size ?? 0) > 1)
  .filter((entry) => !(isSupersetGenre(entry.genre) && entry.count === 0))
  .sort((a, b) =>
    unknownLast(a, b, "genreLabel") ||
    a.genreLabel.localeCompare(b.genreLabel) ||
    a.statusLabel.localeCompare(b.statusLabel));

const enginePlayedEntries = Array.from(enginePlayedCounts.entries())
  .map(([key, count]) => {
    const [engine, status] = key.split("::");
    return {
      engine,
      status,
      count,
      engineLabel: engineLabel.get(engine) ?? formatUnknown(engine, "Engine"),
      statusLabel: labelize(status),
    };
  })
  .filter((entry) => (enginePlayedValues.get(entry.engine)?.size ?? 0) > 1)
  .sort((a, b) =>
    unknownLast(a, b, "engineLabel") ||
    a.engineLabel.localeCompare(b.engineLabel) ||
    a.statusLabel.localeCompare(b.statusLabel));

const developerPlayedEntries = Array.from(developerPlayedCounts.entries())
  .map(([key, count]) => {
    const [developer, status] = key.split("::");
    return {
      developer,
      status,
      count,
      developerLabel: developerLabel.get(developer) ?? formatUnknown(developer, "Developer"),
      statusLabel: labelize(status),
    };
  })
  .filter((entry) => (developerPlayedValues.get(entry.developer)?.size ?? 0) > 1)
  .sort((a, b) =>
    unknownLast(a, b, "developerLabel") ||
    a.developerLabel.localeCompare(b.developerLabel) ||
    a.statusLabel.localeCompare(b.statusLabel));

const genrePlayedEntries = Array.from(genrePlayedTotalCounts.entries())
  .map(([key, totalCount]) => {
    const [genre, status] = key.split("::");
    return {
      genre,
      status,
      count: genrePlayedCounts.get(key) || 0,
      totalCount,
      genreLabel: genreLabel.get(genre) ?? formatUnknown(genre, "Genre"),
      statusLabel: labelize(status),
    };
  })
  .filter((entry) => (genrePlayedValues.get(entry.genre)?.size ?? 0) > 1)
  .filter((entry) => !(isSupersetGenre(entry.genre) && entry.count === 0))
  .sort((a, b) =>
    unknownLast(a, b, "genreLabel") ||
    a.genreLabel.localeCompare(b.genreLabel) ||
    a.statusLabel.localeCompare(b.statusLabel));

const hasAvnGenre = (game) =>
  (game?.genres ?? []).some((entry) => entry?.genres_id?.slug === "avn");
const hasValue = (value) => typeof value === "string" && value.trim().length > 0;
const avnMissingGamestorylogCount = (games ?? []).filter(
  (game) => hasAvnGenre(game) && !hasValue(game.gamestorylog_url),
).length;
const avnWithGamestorylogCount = (games ?? []).filter(
  (game) => hasAvnGenre(game) && hasValue(game.gamestorylog_url),
).length;
const platformCounts = {
  steam: (games ?? []).filter((game) => getDownloadPlatform(game.download_url) === "steam").length,
  itch: (games ?? []).filter((game) => getDownloadPlatform(game.download_url) === "itch").length,
  gog: (games ?? []).filter((game) => getDownloadPlatform(game.download_url) === "gog").length,
  patreon: (games ?? []).filter((game) => getDownloadPlatform(game.download_url) === "patreon").length,
};
const unknownPlatformCount = Math.max(
  0,
  (games?.length ?? 0) -
    platformCounts.steam -
    platformCounts.itch -
    platformCounts.gog -
    platformCounts.patreon,
);
const platformPieSegments = [
  { label: "Steam", value: platformCounts.steam, color: "#4aa3ff" },
  { label: "itch.io", value: platformCounts.itch, color: "#ff7a7a" },
  { label: "GOG", value: platformCounts.gog, color: "#ffd966" },
  { label: "Patreon", value: platformCounts.patreon, color: "#c788ff" },
  { label: formatUnknown("unknown", "Download Platform"), value: unknownPlatformCount, color: "#7fe29a" },
].filter((segment) => segment.value > 0);
const platformPieTotal = platformPieSegments.reduce((sum, segment) => sum + segment.value, 0);
const isUrl = (value) => typeof value === "string" && /^https?:\/\//i.test(value.trim());
const walkthroughCounts = {
  steam: 0,
  itch: 0,
  gog: 0,
  patreon: 0,
  unknown: 0,
  textNote: 0,
  noneProvided: 0,
};
for (const game of games ?? []) {
  const walkthrough = typeof game?.walkthrough_url === "string" ? game.walkthrough_url.trim() : "";
  if (!walkthrough) {
    walkthroughCounts.noneProvided += 1;
    continue;
  }
  if (!isUrl(walkthrough)) {
    walkthroughCounts.textNote += 1;
    continue;
  }
  const platform = getDownloadPlatform(walkthrough);
  if (platform === "steam") walkthroughCounts.steam += 1;
  else if (platform === "itch") walkthroughCounts.itch += 1;
  else if (platform === "gog") walkthroughCounts.gog += 1;
  else if (platform === "patreon") walkthroughCounts.patreon += 1;
  else walkthroughCounts.unknown += 1;
}
const walkthroughPieSegments = [
  { label: "Steam", value: walkthroughCounts.steam, color: "#4aa3ff" },
  { label: "itch.io", value: walkthroughCounts.itch, color: "#ff7a7a" },
  { label: "GOG", value: walkthroughCounts.gog, color: "#ffd966" },
  { label: "Patreon", value: walkthroughCounts.patreon, color: "#c788ff" },
  { label: formatUnknown("unknown", "Walkthrough Platform"), value: walkthroughCounts.unknown, color: "#7fe29a" },
  { label: "Text Note", value: walkthroughCounts.textNote, color: "#ffb86c" },
  { label: "None Provided", value: walkthroughCounts.noneProvided, color: "#999999" },
].filter((segment) => segment.value > 0);
const walkthroughPieTotal = walkthroughPieSegments.reduce((sum, segment) => sum + segment.value, 0);
const pieSize = 220;
const pieRadius = 95;
const pieCenter = pieSize / 2;
const polarToCartesian = (centerX, centerY, radius, angleInDegrees) => {
  const angleInRadians = (angleInDegrees - 90) * (Math.PI / 180.0);
  return {
    x: centerX + radius * Math.cos(angleInRadians),
    y: centerY + radius * Math.sin(angleInRadians),
  };
};
const describeArc = (x, y, radius, startAngle, endAngle) => {
  const start = polarToCartesian(x, y, radius, endAngle);
  const end = polarToCartesian(x, y, radius, startAngle);
  const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
  return `M ${start.x} ${start.y} A ${radius} ${radius} 0 ${largeArcFlag} 0 ${end.x} ${end.y} L ${x} ${y} Z`;
};
const platformPieArcs = (() => {
  if (!platformPieTotal) return [];
  let current = 0;
  return platformPieSegments.map((segment) => {
    const start = current;
    const sweep = (segment.value / platformPieTotal) * 360;
    current += sweep;
    return { ...segment, start, end: current };
  });
})();
const walkthroughPieArcs = (() => {
  if (!walkthroughPieTotal) return [];
  let current = 0;
  return walkthroughPieSegments.map((segment) => {
    const start = current;
    const sweep = (segment.value / walkthroughPieTotal) * 360;
    current += sweep;
    return { ...segment, start, end: current };
  });
})();
const normalizeKey = (value) =>
  String(value ?? "")
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "");
const keyVariants = (value) => {
  const base = normalizeKey(value);
  if (!base) return [];
  const variants = [base];
  if (base.endsWith("s") && base.length > 1) variants.push(base.slice(0, -1));
  return Array.from(new Set(variants));
};
const tierListByGenreSlug = new Map();
const rankedTierLists = [...(tierLists ?? [])].sort((a, b) => {
  const aPublished = a?.status === "published" ? 0 : 1;
  const bPublished = b?.status === "published" ? 0 : 1;
  return aPublished - bPublished;
});
for (const genre of genres ?? []) {
  const genreKeys = new Set(keyVariants(genre?.name));
  const match = rankedTierLists.find((tierList) =>
    keyVariants(tierList?.title).some((key) => genreKeys.has(key)),
  );
  if (genre?.slug && match?.id) {
    tierListByGenreSlug.set(genre.slug, {
      id: match.id,
      title: match.title ?? genre.name,
      genreName: genre.name,
    });
  }
}
const gamesByGenreSlug = new Map();
for (const game of games ?? []) {
  const slugs = (game.genres ?? []).map((entry) => entry?.genres_id?.slug).filter(Boolean);
  for (const slug of slugs) {
    if (!gamesByGenreSlug.has(slug)) gamesByGenreSlug.set(slug, new Set());
    gamesByGenreSlug.get(slug).add(game.id);
  }
}
const relevantTierListIds = Array.from(new Set(Array.from(tierListByGenreSlug.values()).map((item) => item.id)));
const tierEntries = relevantTierListIds.length
  ? await directusFetchItems("tier_entries", {
      fields: ["tier_row.tier_list.id", "game.id"],
      filter: { tier_row: { tier_list: { _in: relevantTierListIds } } },
      limit: 5000,
    })
  : [];
const gameIdsByTierListId = new Map();
for (const entry of tierEntries ?? []) {
  const tierListId = entry?.tier_row?.tier_list?.id;
  const gameId = entry?.game?.id;
  if (typeof tierListId !== "number" || typeof gameId !== "number") continue;
  if (!gameIdsByTierListId.has(tierListId)) gameIdsByTierListId.set(tierListId, new Set());
  gameIdsByTierListId.get(tierListId).add(gameId);
}
const genreTierCoverageEntries = Array.from(tierListByGenreSlug.entries())
  .map(([genreSlug, info]) => {
    const genreGameIds = gamesByGenreSlug.get(genreSlug) ?? new Set();
    const inTierIds = gameIdsByTierListId.get(info.id) ?? new Set();
    let missingCount = 0;
    for (const gameId of genreGameIds) {
      if (!inTierIds.has(gameId)) missingCount += 1;
    }
    return {
      genreSlug,
      genreName: info.genreName,
      tierListTitle: info.title,
      missingCount,
    };
  })
  .filter((entry) => entry.missingCount > 0)
  .sort((a, b) => a.genreName.localeCompare(b.genreName));
const miscCount = 6 + genreTierCoverageEntries.length;
---

<BaseLayout title="Filters">
  <div slot="head">
    <style>
      main{max-width:980px;margin:0 auto;padding:24px;}
      ul{list-style:disc;padding-left:20px;}
      .panel{background:#111;border:1px solid #222;border-radius:12px;padding:16px;margin-bottom:16px;}
      .panel a{color:#9aa6ff;}
      .panel a:visited{color:#9aa6ff;}
      .pie-wrap{display:flex;justify-content:center;margin-top:16px;}
      .pie-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:18px;margin-top:16px;}
      .pie-panel{background:#151515;border:1px solid #252525;border-radius:10px;padding:12px;}
      .pie-panel h3{margin:0 0 8px 0;font-size:1rem;}
      .pie{width:220px;height:220px;border-radius:50%;border:1px solid #2b2b2b;background:#222;display:block;}
      .legend{display:flex;flex-wrap:wrap;gap:10px 16px;justify-content:center;margin-top:12px;padding:0;list-style:none;}
      .legend-item{display:flex;align-items:center;gap:8px;font-size:.85rem;opacity:.9;}
      .legend-swatch{width:12px;height:12px;border-radius:3px;border:1px solid #2b2b2b;display:inline-block;}
    </style>
  </div>
  <main>
    <div class="panel">
      <h1>Filters</h1>
      <p>Composite filter pages generated at build time.</p>
    </div>
    <div class="panel">
      <h2>Jump to Section</h2>
      <ul>
        <li><a href="#developer-game-status">Developer + Game Status ({developerStatusEntries.length})</a></li>
        <li><a href="#developer-played-status">Developer + Played Status ({developerPlayedEntries.length})</a></li>
        <li><a href="#engine-game-status">Engine + Game Status ({engineStatusEntries.length})</a></li>
        <li><a href="#engine-genre">Engine + Genre ({engineGenreEntries.length})</a></li>
        <li><a href="#engine-played-status">Engine + Played Status ({enginePlayedEntries.length})</a></li>
        <li><a href="#genre-game-status">Genre + Game Status ({genreStatusEntries.length})</a></li>
        <li><a href="#genre-played-status">Genre + Played Status ({genrePlayedEntries.length})</a></li>
        <li><a href="#misc">Misc ({miscCount})</a></li>
      </ul>
    </div>
    <div class="panel" id="developer-game-status">
      <h2>Developer + Game Status ({developerStatusEntries.length} combinations)</h2>
      <p style="opacity:.7;margin-top:-8px;">Combinations with only one status per developer are hidden.</p>
      {developerStatusEntries.length === 0 ? (
        <p>No combinations yet.</p>
      ) : (
        <ul>
          {developerStatusEntries.map((entry) => (
            <li>
              <a href={`/filters/developer/${entry.developer}/game_status/${entry.status}/index.html`}>{entry.developerLabel} + {entry.statusLabel}</a>
              <span style="opacity:.7;"> ({entry.count})</span>
            </li>
          ))}
        </ul>
      )}
    </div>
    <div class="panel" id="developer-played-status">
      <h2>Developer + Played Status ({developerPlayedEntries.length} combinations)</h2>
      <p style="opacity:.7;margin-top:-8px;">Combinations with only one status per developer are hidden.</p>
      {developerPlayedEntries.length === 0 ? (
        <p>No combinations yet.</p>
      ) : (
        <ul>
          {developerPlayedEntries.map((entry) => (
            <li>
              <a href={`/filters/developer/${entry.developer}/played_status/${entry.status}/index.html`}>{entry.developerLabel} + {entry.statusLabel}</a>
              <span style="opacity:.7;"> ({entry.count})</span>
            </li>
          ))}
        </ul>
      )}
    </div>
    <div class="panel" id="engine-game-status">
      <h2>Engine + Game Status ({engineStatusEntries.length} combinations)</h2>
      <p style="opacity:.7;margin-top:-8px;">Combinations with only one status per engine are hidden.</p>
      {engineStatusEntries.length === 0 ? (
        <p>No combinations yet.</p>
      ) : (
        <ul>
          {engineStatusEntries.map((entry) => (
            <li>
              <a href={`/filters/engine/${entry.engine}/game_status/${entry.status}/index.html`}>{entry.engineLabel} + {entry.statusLabel}</a>
              <span style="opacity:.7;"> ({entry.count})</span>
            </li>
          ))}
        </ul>
      )}
    </div>
    <div class="panel" id="engine-genre">
      <h2>Engine + Genre ({engineGenreEntries.length} combinations)</h2>
      <p style="opacity:.7;margin-top:-8px;">Superset genres with zero distinct matches are hidden.</p>
      {engineGenreEntries.length === 0 ? (
        <p>No combinations yet.</p>
      ) : (
        <ul>
          {engineGenreEntries.map((entry) => (
            <li>
              <a href={`/filters/engine/${entry.engine}/genre/${entry.genre}/index.html`}>{entry.engineLabel} + {entry.genreLabel}</a>
              {isSupersetGenre(entry.genre) ? (
                <span style="opacity:.7;"> ({entry.count} distinct, {entry.totalCount} total)</span>
              ) : (
                <span style="opacity:.7;"> ({entry.count})</span>
              )}
            </li>
          ))}
        </ul>
      )}
    </div>
    <div class="panel" id="engine-played-status">
      <h2>Engine + Played Status ({enginePlayedEntries.length} combinations)</h2>
      <p style="opacity:.7;margin-top:-8px;">Combinations with only one status per engine are hidden.</p>
      {enginePlayedEntries.length === 0 ? (
        <p>No combinations yet.</p>
      ) : (
        <ul>
          {enginePlayedEntries.map((entry) => (
            <li>
              <a href={`/filters/engine/${entry.engine}/played_status/${entry.status}/index.html`}>{entry.engineLabel} + {entry.statusLabel}</a>
              <span style="opacity:.7;"> ({entry.count})</span>
            </li>
          ))}
        </ul>
      )}
    </div>
    <div class="panel" id="genre-game-status">
      <h2>Genre + Game Status ({genreStatusEntries.length} combinations)</h2>
      <p style="opacity:.7;margin-top:-8px;">Combinations with only one status per genre are hidden. Superset genres with zero distinct matches are hidden.</p>
      {genreStatusEntries.length === 0 ? (
        <p>No combinations yet.</p>
      ) : (
        <ul>
          {genreStatusEntries.map((entry) => (
            <li>
              <a href={`/filters/genre/${entry.genre}/game_status/${entry.status}/index.html`}>{entry.genreLabel} + {entry.statusLabel}</a>
              {isSupersetGenre(entry.genre) ? (
                <span style="opacity:.7;"> ({entry.count} distinct, {entry.totalCount} total)</span>
              ) : (
                <span style="opacity:.7;"> ({entry.count})</span>
              )}
            </li>
          ))}
        </ul>
      )}
    </div>
    <div class="panel" id="genre-played-status">
      <h2>Genre + Played Status ({genrePlayedEntries.length} combinations)</h2>
      <p style="opacity:.7;margin-top:-8px;">Combinations with only one status per genre are hidden. Superset genres with zero distinct matches are hidden.</p>
      {genrePlayedEntries.length === 0 ? (
        <p>No combinations yet.</p>
      ) : (
        <ul>
          {genrePlayedEntries.map((entry) => (
            <li>
              <a href={`/filters/genre/${entry.genre}/played_status/${entry.status}/index.html`}>{entry.genreLabel} + {entry.statusLabel}</a>
              {isSupersetGenre(entry.genre) ? (
                <span style="opacity:.7;"> ({entry.count} distinct, {entry.totalCount} total)</span>
              ) : (
                <span style="opacity:.7;"> ({entry.count})</span>
              )}
            </li>
          ))}
        </ul>
      )}
    </div>
    <div class="panel" id="misc">
      <h2>Misc ({miscCount} combinations)</h2>
      <ul>
        <li>
          <a href="/filters/misc/avn-missing-gamestorylog/index.html">AVN + Missing GameStoryLog URL</a>
          <span style="opacity:.7;"> ({avnMissingGamestorylogCount})</span>
        </li>
        <li>
          <a href="/filters/misc/avn-with-gamestorylog/index.html">AVN + Has GameStoryLog URL</a>
          <span style="opacity:.7;"> ({avnWithGamestorylogCount})</span>
        </li>
        <li>
          <a href="/filters/misc/platform/steam/index.html">Download Platform + Steam</a>
          <span style="opacity:.7;"> ({platformCounts.steam})</span>
        </li>
        <li>
          <a href="/filters/misc/platform/itch/index.html">Download Platform + itch.io</a>
          <span style="opacity:.7;"> ({platformCounts.itch})</span>
        </li>
        <li>
          <a href="/filters/misc/platform/gog/index.html">Download Platform + GOG</a>
          <span style="opacity:.7;"> ({platformCounts.gog})</span>
        </li>
        <li>
          <a href="/filters/misc/platform/patreon/index.html">Download Platform + Patreon</a>
          <span style="opacity:.7;"> ({platformCounts.patreon})</span>
        </li>
        {genreTierCoverageEntries.map((entry) => (
          <li>
            <a href={`/filters/misc/genre-not-in-tier/${entry.genreSlug}/index.html`}>
              {entry.genreName} + Missing from {entry.tierListTitle} Tier List
            </a>
            <span style="opacity:.7;"> ({entry.missingCount})</span>
          </li>
        ))}
      </ul>
      {platformPieSegments.length || walkthroughPieSegments.length ? (
        <div class="pie-grid">
          {platformPieSegments.length ? (
          <div class="pie-panel">
            <h3>Download URL Platform</h3>
            <div class="pie-wrap">
              <svg class="pie" viewBox={`0 0 ${pieSize} ${pieSize}`} role="img" aria-label="Download platform distribution">
                {platformPieArcs.length === 1 ? (
                  <circle cx={pieCenter} cy={pieCenter} r={pieRadius} fill={platformPieArcs[0].color}>
                    <title>{platformPieArcs[0].label} ({platformPieArcs[0].value})</title>
                  </circle>
                ) : (
                  platformPieArcs.map((segment) => (
                    <path d={describeArc(pieCenter, pieCenter, pieRadius, segment.start, segment.end)} fill={segment.color}>
                      <title>{segment.label} ({segment.value})</title>
                    </path>
                  ))
                )}
              </svg>
            </div>
            <ul class="legend" aria-label="Download URL platform legend">
              {platformPieSegments.map((segment) => (
                <li class="legend-item">
                  <span class="legend-swatch" style={`background:${segment.color};`}></span>
                  <span>{segment.label} ({segment.value})</span>
                </li>
              ))}
            </ul>
          </div>
          ) : null}
          {walkthroughPieSegments.length ? (
          <div class="pie-panel">
            <h3>Walkthrough URL Platform</h3>
            <div class="pie-wrap">
              <svg class="pie" viewBox={`0 0 ${pieSize} ${pieSize}`} role="img" aria-label="Walkthrough platform distribution">
                {walkthroughPieArcs.length === 1 ? (
                  <circle cx={pieCenter} cy={pieCenter} r={pieRadius} fill={walkthroughPieArcs[0].color}>
                    <title>{walkthroughPieArcs[0].label} ({walkthroughPieArcs[0].value})</title>
                  </circle>
                ) : (
                  walkthroughPieArcs.map((segment) => (
                    <path d={describeArc(pieCenter, pieCenter, pieRadius, segment.start, segment.end)} fill={segment.color}>
                      <title>{segment.label} ({segment.value})</title>
                    </path>
                  ))
                )}
              </svg>
            </div>
            <ul class="legend" aria-label="Walkthrough URL platform legend">
              {walkthroughPieSegments.map((segment) => (
                <li class="legend-item">
                  <span class="legend-swatch" style={`background:${segment.color};`}></span>
                  <span>{segment.label} ({segment.value})</span>
                </li>
              ))}
            </ul>
          </div>
          ) : null}
        </div>
      ) : null}
    </div>
  </main>
</BaseLayout>
