---
import BaseLayout from "../../layouts/BaseLayout.astro";
import { directusFetchItems } from "../../lib/directus";
import { GENRE_SUPERSETS, normalizeGenreSlugs } from "../../lib/genre-supersets";
import { formatUnknown } from "../../lib/list-format";

const engines = await directusFetchItems("engines", {
  fields: ["slug", "title"],
  sort: ["title"],
  limit: 500,
});
const genres = await directusFetchItems("genres", {
  fields: ["slug", "name"],
  sort: ["name"],
  limit: 500,
});
const developers = await directusFetchItems("developers", {
  fields: ["slug", "name"],
  sort: ["name"],
  limit: 500,
});
const games = await directusFetchItems("games", {
  fields: [
    "id",
    "game_status",
    "player_status",
    "engines.engines_id.slug",
    "genres.genres_id.slug",
    "developers.developers_id.slug",
  ],
  limit: 1000,
});

const engineLabel = new Map();
for (const engine of engines ?? []) {
  if (engine?.slug) engineLabel.set(engine.slug, engine.title ?? engine.slug);
}
const genreLabel = new Map();
for (const genre of genres ?? []) {
  if (genre?.slug) genreLabel.set(genre.slug, genre.name ?? genre.slug);
}
const developerLabel = new Map();
for (const developer of developers ?? []) {
  if (developer?.slug) {
    developerLabel.set(developer.slug, developer.name ?? developer.slug);
  }
}

const engineGenreCounts = new Map();
const engineGenreTotalCounts = new Map();
const engineStatusCounts = new Map();
const engineStatusValues = new Map();
const developerStatusCounts = new Map();
const developerStatusValues = new Map();
const genreStatusCounts = new Map();
const genreStatusTotalCounts = new Map();
const genreStatusValues = new Map();
const enginePlayedCounts = new Map();
const enginePlayedValues = new Map();
const developerPlayedCounts = new Map();
const developerPlayedValues = new Map();
const genrePlayedCounts = new Map();
const genrePlayedTotalCounts = new Map();
const genrePlayedValues = new Map();

for (const game of games ?? []) {
  const engineSlugs =
    (game.engines ?? []).map((entry) => entry?.engines_id?.slug).filter(Boolean);
  const rawGenreSlugs =
    (game.genres ?? []).map((entry) => entry?.genres_id?.slug).filter(Boolean);
  const distinctGenreSlugs = normalizeGenreSlugs(rawGenreSlugs);
  const developerSlugs =
    (game.developers ?? []).map((entry) => entry?.developers_id?.slug).filter(Boolean);

  const enginesForGame = engineSlugs.length ? engineSlugs : ["unknown"];
  const totalGenresForGame = rawGenreSlugs.length ? rawGenreSlugs : ["unknown"];
  const distinctGenresForGame = distinctGenreSlugs.length ? distinctGenreSlugs : ["unknown"];
  const developersForGame = developerSlugs.length ? developerSlugs : ["unknown"];

  for (const engine of enginesForGame) {
    for (const genre of distinctGenresForGame) {
      const key = `${engine}::${genre}`;
      engineGenreCounts.set(key, (engineGenreCounts.get(key) || 0) + 1);
    }
  }
  for (const engine of enginesForGame) {
    for (const genre of totalGenresForGame) {
      const key = `${engine}::${genre}`;
      engineGenreTotalCounts.set(key, (engineGenreTotalCounts.get(key) || 0) + 1);
    }
  }

  if (game.game_status) {
    for (const engine of enginesForGame) {
      const key = `${engine}::${game.game_status}`;
      engineStatusCounts.set(key, (engineStatusCounts.get(key) || 0) + 1);
      if (!engineStatusValues.has(engine)) {
        engineStatusValues.set(engine, new Set());
      }
      engineStatusValues.get(engine).add(game.game_status);
    }
    for (const developer of developersForGame) {
      const key = `${developer}::${game.game_status}`;
      developerStatusCounts.set(key, (developerStatusCounts.get(key) || 0) + 1);
      if (!developerStatusValues.has(developer)) {
        developerStatusValues.set(developer, new Set());
      }
      developerStatusValues.get(developer).add(game.game_status);
    }
    for (const genre of distinctGenresForGame) {
      const key = `${genre}::${game.game_status}`;
      genreStatusCounts.set(key, (genreStatusCounts.get(key) || 0) + 1);
      if (!genreStatusValues.has(genre)) {
        genreStatusValues.set(genre, new Set());
      }
      genreStatusValues.get(genre).add(game.game_status);
    }
    for (const genre of totalGenresForGame) {
      const key = `${genre}::${game.game_status}`;
      genreStatusTotalCounts.set(key, (genreStatusTotalCounts.get(key) || 0) + 1);
    }
  }

  if (game.player_status) {
    for (const engine of enginesForGame) {
      const key = `${engine}::${game.player_status}`;
      enginePlayedCounts.set(key, (enginePlayedCounts.get(key) || 0) + 1);
      if (!enginePlayedValues.has(engine)) {
        enginePlayedValues.set(engine, new Set());
      }
      enginePlayedValues.get(engine).add(game.player_status);
    }
    for (const developer of developersForGame) {
      const key = `${developer}::${game.player_status}`;
      developerPlayedCounts.set(key, (developerPlayedCounts.get(key) || 0) + 1);
      if (!developerPlayedValues.has(developer)) {
        developerPlayedValues.set(developer, new Set());
      }
      developerPlayedValues.get(developer).add(game.player_status);
    }
    for (const genre of distinctGenresForGame) {
      const key = `${genre}::${game.player_status}`;
      genrePlayedCounts.set(key, (genrePlayedCounts.get(key) || 0) + 1);
      if (!genrePlayedValues.has(genre)) {
        genrePlayedValues.set(genre, new Set());
      }
      genrePlayedValues.get(genre).add(game.player_status);
    }
    for (const genre of totalGenresForGame) {
      const key = `${genre}::${game.player_status}`;
      genrePlayedTotalCounts.set(key, (genrePlayedTotalCounts.get(key) || 0) + 1);
    }
  }
}

const labelize = (value) =>
  value ? value.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase()) : "";
const unknownLast = (a, b, key) => {
  const aUnknown = a[key]?.startsWith("<Unknown ");
  const bUnknown = b[key]?.startsWith("<Unknown ");
  if (aUnknown !== bUnknown) return aUnknown ? 1 : -1;
  return 0;
};
const isSupersetGenre = (slug) =>
  Object.prototype.hasOwnProperty.call(GENRE_SUPERSETS, slug);

const engineGenreEntries = Array.from(engineGenreTotalCounts.entries())
  .map(([key, totalCount]) => {
    const [engine, genre] = key.split("::");
    return {
      engine,
      genre,
      count: engineGenreCounts.get(key) || 0,
      totalCount,
      engineLabel: engineLabel.get(engine) ?? formatUnknown(engine, "Engine"),
      genreLabel: genreLabel.get(genre) ?? formatUnknown(genre, "Genre"),
    };
  })
  .filter((entry) => !(isSupersetGenre(entry.genre) && entry.count === 0))
  .sort((a, b) =>
    unknownLast(a, b, "engineLabel") ||
    a.engineLabel.localeCompare(b.engineLabel) ||
    unknownLast(a, b, "genreLabel") ||
    a.genreLabel.localeCompare(b.genreLabel));


const engineStatusEntries = Array.from(engineStatusCounts.entries())
  .map(([key, count]) => {
    const [engine, status] = key.split("::");
    return {
      engine,
      status,
      count,
      engineLabel: engineLabel.get(engine) ?? formatUnknown(engine, "Engine"),
      statusLabel: labelize(status),
    };
  })
  .filter((entry) => (engineStatusValues.get(entry.engine)?.size ?? 0) > 1)
  .sort((a, b) =>
    unknownLast(a, b, "engineLabel") ||
    a.engineLabel.localeCompare(b.engineLabel) ||
    a.statusLabel.localeCompare(b.statusLabel));

const developerStatusEntries = Array.from(developerStatusCounts.entries())
  .map(([key, count]) => {
    const [developer, status] = key.split("::");
    return {
      developer,
      status,
      count,
      developerLabel: developerLabel.get(developer) ?? formatUnknown(developer, "Developer"),
      statusLabel: labelize(status),
    };
  })
  .filter((entry) => (developerStatusValues.get(entry.developer)?.size ?? 0) > 1)
  .sort((a, b) =>
    unknownLast(a, b, "developerLabel") ||
    a.developerLabel.localeCompare(b.developerLabel) ||
    a.statusLabel.localeCompare(b.statusLabel));

const genreStatusEntries = Array.from(genreStatusTotalCounts.entries())
  .map(([key, totalCount]) => {
    const [genre, status] = key.split("::");
    return {
      genre,
      status,
      count: genreStatusCounts.get(key) || 0,
      totalCount,
      genreLabel: genreLabel.get(genre) ?? formatUnknown(genre, "Genre"),
      statusLabel: labelize(status),
    };
  })
  .filter((entry) => (genreStatusValues.get(entry.genre)?.size ?? 0) > 1)
  .filter((entry) => !(isSupersetGenre(entry.genre) && entry.count === 0))
  .sort((a, b) =>
    unknownLast(a, b, "genreLabel") ||
    a.genreLabel.localeCompare(b.genreLabel) ||
    a.statusLabel.localeCompare(b.statusLabel));

const enginePlayedEntries = Array.from(enginePlayedCounts.entries())
  .map(([key, count]) => {
    const [engine, status] = key.split("::");
    return {
      engine,
      status,
      count,
      engineLabel: engineLabel.get(engine) ?? formatUnknown(engine, "Engine"),
      statusLabel: labelize(status),
    };
  })
  .filter((entry) => (enginePlayedValues.get(entry.engine)?.size ?? 0) > 1)
  .sort((a, b) =>
    unknownLast(a, b, "engineLabel") ||
    a.engineLabel.localeCompare(b.engineLabel) ||
    a.statusLabel.localeCompare(b.statusLabel));

const developerPlayedEntries = Array.from(developerPlayedCounts.entries())
  .map(([key, count]) => {
    const [developer, status] = key.split("::");
    return {
      developer,
      status,
      count,
      developerLabel: developerLabel.get(developer) ?? formatUnknown(developer, "Developer"),
      statusLabel: labelize(status),
    };
  })
  .filter((entry) => (developerPlayedValues.get(entry.developer)?.size ?? 0) > 1)
  .sort((a, b) =>
    unknownLast(a, b, "developerLabel") ||
    a.developerLabel.localeCompare(b.developerLabel) ||
    a.statusLabel.localeCompare(b.statusLabel));

const genrePlayedEntries = Array.from(genrePlayedTotalCounts.entries())
  .map(([key, totalCount]) => {
    const [genre, status] = key.split("::");
    return {
      genre,
      status,
      count: genrePlayedCounts.get(key) || 0,
      totalCount,
      genreLabel: genreLabel.get(genre) ?? formatUnknown(genre, "Genre"),
      statusLabel: labelize(status),
    };
  })
  .filter((entry) => (genrePlayedValues.get(entry.genre)?.size ?? 0) > 1)
  .filter((entry) => !(isSupersetGenre(entry.genre) && entry.count === 0))
  .sort((a, b) =>
    unknownLast(a, b, "genreLabel") ||
    a.genreLabel.localeCompare(b.genreLabel) ||
    a.statusLabel.localeCompare(b.statusLabel));
---

<BaseLayout title="Filters">
  <div slot="head">
    <style>
      main{max-width:980px;margin:0 auto;padding:24px;}
      ul{list-style:disc;padding-left:20px;}
      .panel{background:#111;border:1px solid #222;border-radius:12px;padding:16px;margin-bottom:16px;}
      .panel a{color:#9aa6ff;}
      .panel a:visited{color:#9aa6ff;}
    </style>
  </div>
  <main>
    <div class="panel">
      <h1>Filters</h1>
      <p>Composite filter pages generated at build time.</p>
    </div>
    <div class="panel">
      <h2>Jump to Section</h2>
      <ul>
        <li><a href="#developer-game-status">Developer + Game Status ({developerStatusEntries.length})</a></li>
        <li><a href="#developer-played-status">Developer + Played Status ({developerPlayedEntries.length})</a></li>
        <li><a href="#engine-game-status">Engine + Game Status ({engineStatusEntries.length})</a></li>
        <li><a href="#engine-genre">Engine + Genre ({engineGenreEntries.length})</a></li>
        <li><a href="#engine-played-status">Engine + Played Status ({enginePlayedEntries.length})</a></li>
        <li><a href="#genre-game-status">Genre + Game Status ({genreStatusEntries.length})</a></li>
        <li><a href="#genre-played-status">Genre + Played Status ({genrePlayedEntries.length})</a></li>
      </ul>
    </div>
    <div class="panel" id="developer-game-status">
      <h2>Developer + Game Status ({developerStatusEntries.length} combinations)</h2>
      <p style="opacity:.7;margin-top:-8px;">Combinations with only one status per developer are hidden.</p>
      {developerStatusEntries.length === 0 ? (
        <p>No combinations yet.</p>
      ) : (
        <ul>
          {developerStatusEntries.map((entry) => (
            <li>
              <a href={`/filters/developer/${entry.developer}/game_status/${entry.status}/index.html`}>{entry.developerLabel} + {entry.statusLabel}</a>
              <span style="opacity:.7;"> ({entry.count})</span>
            </li>
          ))}
        </ul>
      )}
    </div>
    <div class="panel" id="developer-played-status">
      <h2>Developer + Played Status ({developerPlayedEntries.length} combinations)</h2>
      <p style="opacity:.7;margin-top:-8px;">Combinations with only one status per developer are hidden.</p>
      {developerPlayedEntries.length === 0 ? (
        <p>No combinations yet.</p>
      ) : (
        <ul>
          {developerPlayedEntries.map((entry) => (
            <li>
              <a href={`/filters/developer/${entry.developer}/played_status/${entry.status}/index.html`}>{entry.developerLabel} + {entry.statusLabel}</a>
              <span style="opacity:.7;"> ({entry.count})</span>
            </li>
          ))}
        </ul>
      )}
    </div>
    <div class="panel" id="engine-game-status">
      <h2>Engine + Game Status ({engineStatusEntries.length} combinations)</h2>
      <p style="opacity:.7;margin-top:-8px;">Combinations with only one status per engine are hidden.</p>
      {engineStatusEntries.length === 0 ? (
        <p>No combinations yet.</p>
      ) : (
        <ul>
          {engineStatusEntries.map((entry) => (
            <li>
              <a href={`/filters/engine/${entry.engine}/game_status/${entry.status}/index.html`}>{entry.engineLabel} + {entry.statusLabel}</a>
              <span style="opacity:.7;"> ({entry.count})</span>
            </li>
          ))}
        </ul>
      )}
    </div>
    <div class="panel" id="engine-genre">
      <h2>Engine + Genre ({engineGenreEntries.length} combinations)</h2>
      <p style="opacity:.7;margin-top:-8px;">Superset genres with zero distinct matches are hidden.</p>
      {engineGenreEntries.length === 0 ? (
        <p>No combinations yet.</p>
      ) : (
        <ul>
          {engineGenreEntries.map((entry) => (
            <li>
              <a href={`/filters/engine/${entry.engine}/genre/${entry.genre}/index.html`}>{entry.engineLabel} + {entry.genreLabel}</a>
              {isSupersetGenre(entry.genre) ? (
                <span style="opacity:.7;"> ({entry.count} distinct, {entry.totalCount} total)</span>
              ) : (
                <span style="opacity:.7;"> ({entry.count})</span>
              )}
            </li>
          ))}
        </ul>
      )}
    </div>
    <div class="panel" id="engine-played-status">
      <h2>Engine + Played Status ({enginePlayedEntries.length} combinations)</h2>
      <p style="opacity:.7;margin-top:-8px;">Combinations with only one status per engine are hidden.</p>
      {enginePlayedEntries.length === 0 ? (
        <p>No combinations yet.</p>
      ) : (
        <ul>
          {enginePlayedEntries.map((entry) => (
            <li>
              <a href={`/filters/engine/${entry.engine}/played_status/${entry.status}/index.html`}>{entry.engineLabel} + {entry.statusLabel}</a>
              <span style="opacity:.7;"> ({entry.count})</span>
            </li>
          ))}
        </ul>
      )}
    </div>
    <div class="panel" id="genre-game-status">
      <h2>Genre + Game Status ({genreStatusEntries.length} combinations)</h2>
      <p style="opacity:.7;margin-top:-8px;">Combinations with only one status per genre are hidden. Superset genres with zero distinct matches are hidden.</p>
      {genreStatusEntries.length === 0 ? (
        <p>No combinations yet.</p>
      ) : (
        <ul>
          {genreStatusEntries.map((entry) => (
            <li>
              <a href={`/filters/genre/${entry.genre}/game_status/${entry.status}/index.html`}>{entry.genreLabel} + {entry.statusLabel}</a>
              {isSupersetGenre(entry.genre) ? (
                <span style="opacity:.7;"> ({entry.count} distinct, {entry.totalCount} total)</span>
              ) : (
                <span style="opacity:.7;"> ({entry.count})</span>
              )}
            </li>
          ))}
        </ul>
      )}
    </div>
    <div class="panel" id="genre-played-status">
      <h2>Genre + Played Status ({genrePlayedEntries.length} combinations)</h2>
      <p style="opacity:.7;margin-top:-8px;">Combinations with only one status per genre are hidden. Superset genres with zero distinct matches are hidden.</p>
      {genrePlayedEntries.length === 0 ? (
        <p>No combinations yet.</p>
      ) : (
        <ul>
          {genrePlayedEntries.map((entry) => (
            <li>
              <a href={`/filters/genre/${entry.genre}/played_status/${entry.status}/index.html`}>{entry.genreLabel} + {entry.statusLabel}</a>
              {isSupersetGenre(entry.genre) ? (
                <span style="opacity:.7;"> ({entry.count} distinct, {entry.totalCount} total)</span>
              ) : (
                <span style="opacity:.7;"> ({entry.count})</span>
              )}
            </li>
          ))}
        </ul>
      )}
    </div>
  </main>
</BaseLayout>
