---
import BaseLayout from "../../../../../layouts/BaseLayout.astro";
import GameThumbCard from "../../../../../components/GameThumbCard.astro";
import { directusFetchItems } from "../../../../../lib/directus";
import { GAME_THUMB_FIELDS } from "../../../../../lib/game-fields";
import { normalizeGenreSlugs, shouldExcludeSuperset } from "../../../../../lib/genre-supersets";

export async function getStaticPaths() {
  const games = await directusFetchItems("games", {
    fields: [
      "id",
      "engines.engines_id.slug",
      "genres.genres_id.slug",
    ],
    limit: 1000,
  });

  const comboCounts = new Map();
  for (const game of games ?? []) {
    const engineSlugs =
      (game.engines ?? []).map((entry) => entry?.engines_id?.slug).filter(Boolean);
    const rawGenreSlugs =
      (game.genres ?? []).map((entry) => entry?.genres_id?.slug).filter(Boolean);
    const genreSlugs = normalizeGenreSlugs(rawGenreSlugs);
    const enginesForGame = engineSlugs.length ? engineSlugs : ["unknown"];
    const genresForGame = genreSlugs.length ? genreSlugs : ["unknown"];
    for (const engine of enginesForGame) {
      for (const genre of genresForGame) {
        const key = `${engine}::${genre}`;
        comboCounts.set(key, (comboCounts.get(key) || 0) + 1);
      }
    }
  }

  return Array.from(comboCounts.keys()).map((key) => {
    const [engine, genre] = key.split("::");
    return { params: { engine, genre } };
  });
}

const { engine, genre } = Astro.params;

const engines = await directusFetchItems("engines", {
  fields: ["slug", "title"],
  filter: { slug: { _eq: engine } },
  limit: 1,
});
const genres = await directusFetchItems("genres", {
  fields: ["slug", "name"],
  filter: { slug: { _eq: genre } },
  limit: 1,
});

const engineLabel = engine === "unknown" ? "Unknown" : (engines?.[0]?.title ?? engine);
const genreLabel = genre === "unknown" ? "Unknown" : (genres?.[0]?.name ?? genre);

const filter = {};
if (engine !== "unknown") {
  filter.engines = { engines_id: { slug: { _eq: engine } } };
}
if (genre !== "unknown") {
  filter.genres = { genres_id: { slug: { _eq: genre } } };
}

let games = await directusFetchItems("games", {
  fields: GAME_THUMB_FIELDS,
  filter: Object.keys(filter).length ? filter : undefined,
  sort: ["title"],
  limit: 1000,
});

if (engine === "unknown") {
  games = games.filter((game) => (game.engines ?? []).length === 0);
}
if (genre === "unknown") {
  games = games.filter((game) => (game.genres ?? []).length === 0);
}
games = games.filter((game) =>
  !shouldExcludeSuperset(
    genre,
    (game.genres ?? []).map((entry) => entry?.genres_id?.slug).filter(Boolean),
  ),
);

const gameIds = games.map((game) => game.id).filter((id) => typeof id === "number");
const reviewedGameIds = new Set();
if (gameIds.length) {
  const reviews = await directusFetchItems("reviews", {
    fields: ["game.id"],
    filter: { status: { _eq: "published" }, game: { _in: gameIds } },
    limit: 500,
  });
  for (const review of reviews ?? []) {
    const id = review?.game?.id;
    if (typeof id === "number") reviewedGameIds.add(id);
  }
}
---

<BaseLayout title={`Filters | ${engineLabel} + ${genreLabel}`}>
  <div slot="head">
    <style>
      main{padding:2rem;}
      .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:1rem;}
      .panel{background:#111;border:1px solid #222;border-radius:12px;padding:16px;margin-bottom:16px;}
      .panel a{color:#9aa6ff;}
      .panel a:visited{color:#9aa6ff;}
    </style>
  </div>
  <main>
    <div class="panel">
      <h1>{engineLabel} + {genreLabel}</h1>
      <p>
        Engine: <strong>{engineLabel}</strong> &nbsp;|&nbsp;
        Genre: <strong>{genreLabel}</strong>
      </p>
    </div>
    {games.length === 0 ? (
      <p>No games found for this combination.</p>
    ) : (
      <div class="grid">
        {games.map((game) => {
          const reviewed = reviewedGameIds.has(game.id);
          return <GameThumbCard game={game} reviewed={reviewed} />;
        })}
      </div>
    )}
  </main>
</BaseLayout>
