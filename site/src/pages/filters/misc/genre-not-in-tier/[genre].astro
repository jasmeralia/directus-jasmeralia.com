---
import BaseLayout from "../../../../layouts/BaseLayout.astro";
import CsvHeader from "../../../../components/CsvHeader.astro";
import ThumbnailBorderLegend from "../../../../components/ThumbnailBorderLegend.astro";
import GameThumbCard from "../../../../components/GameThumbCard.astro";
import { directusFetchItems, getSTierGameIds } from "../../../../lib/directus";
import { csvDataUri, gamesToCsv } from "../../../../lib/csv";
import { GAME_THUMB_FIELDS } from "../../../../lib/game-fields";

export async function getStaticPaths() {
  const normalizeKey = (value) =>
    String(value ?? "")
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "");
  const keyVariants = (value) => {
    const base = normalizeKey(value);
    if (!base) return [];
    const variants = [base];
    if (base.endsWith("s") && base.length > 1) variants.push(base.slice(0, -1));
    return Array.from(new Set(variants));
  };
  const genres = await directusFetchItems("genres", {
    fields: ["slug", "name"],
    limit: 500,
  });
  const tierLists = await directusFetchItems("tier_lists", {
    fields: ["title", "status"],
    limit: 500,
  });
  const rankedTierLists = [...(tierLists ?? [])].sort((a, b) => {
    const aPublished = a?.status === "published" ? 0 : 1;
    const bPublished = b?.status === "published" ? 0 : 1;
    return aPublished - bPublished;
  });
  return (genres ?? [])
    .filter((genre) => {
      if (!genre?.slug) return false;
      const genreKeys = new Set(keyVariants(genre?.name));
      return rankedTierLists.some((tierList) =>
        keyVariants(tierList?.title).some((key) => genreKeys.has(key)),
      );
    })
    .map((genre) => ({ params: { genre: genre.slug } }));
}

const { genre } = Astro.params;

const genres = await directusFetchItems("genres", {
  fields: ["slug", "name"],
  filter: { slug: { _eq: genre } },
  limit: 1,
});
const genreInfo = genres?.[0];
if (!genreInfo?.name) throw new Error(`Genre not found for slug: ${genre}`);

const tierLists = await directusFetchItems("tier_lists", {
  fields: ["id", "title", "status"],
  limit: 500,
});
const normalizeKey = (value) =>
  String(value ?? "")
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "");
const keyVariants = (value) => {
  const base = normalizeKey(value);
  if (!base) return [];
  const variants = [base];
  if (base.endsWith("s") && base.length > 1) variants.push(base.slice(0, -1));
  return Array.from(new Set(variants));
};
const genreKeys = new Set(keyVariants(genreInfo.name));
const rankedTierLists = [...(tierLists ?? [])].sort((a, b) => {
  const aPublished = a?.status === "published" ? 0 : 1;
  const bPublished = b?.status === "published" ? 0 : 1;
  return aPublished - bPublished;
});
const matchingTierLists = rankedTierLists.filter((tierList) =>
  keyVariants(tierList?.title).some((key) => genreKeys.has(key)),
);
if (!matchingTierLists.length) throw new Error(`No tier list found matching genre: ${genreInfo.name}`);
const tierListIds = matchingTierLists.map((tierList) => tierList.id).filter((id) => typeof id === "number");

const games = await directusFetchItems("games", {
  fields: GAME_THUMB_FIELDS,
  filter: { genres: { genres_id: { slug: { _eq: genre } } } },
  sort: ["title"],
  limit: 1000,
});
const gameIds = games.map((game) => game.id).filter((id) => typeof id === "number");

const tierEntries = tierListIds.length && gameIds.length
  ? await directusFetchItems("tier_entries", {
      fields: ["game.id"],
      filter: {
        game: { _in: gameIds },
        tier_row: { tier_list: { _in: tierListIds } },
      },
      limit: 5000,
    })
  : [];
const inTierGameIds = new Set(
  (tierEntries ?? []).map((entry) => entry?.game?.id).filter((id) => typeof id === "number"),
);
const filteredGames = (games ?? []).filter((game) => !inTierGameIds.has(game.id));

const filteredGameIds = filteredGames
  .map((game) => game.id)
  .filter((id) => typeof id === "number");
const sTierGameIds = await getSTierGameIds(filteredGameIds);
const reviewedGameIds = new Set();
if (filteredGameIds.length) {
  const reviews = await directusFetchItems("reviews", {
    fields: ["game.id"],
    filter: { status: { _eq: "published" }, game: { _in: filteredGameIds } },
    limit: 500,
  });
  for (const review of reviews ?? []) {
    const id = review?.game?.id;
    if (typeof id === "number") reviewedGameIds.add(id);
  }
}

const csvName = `${genre}-missing-from-tier-list.csv`;
const csvHref = csvDataUri(gamesToCsv(filteredGames));
---

<BaseLayout title={`Filters | ${genreInfo.name} Missing from Tier List`}>
  <div slot="head">
    <style>
      main{padding:2rem;}
      .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:1rem;}
      .panel{background:#111;border:1px solid #222;border-radius:12px;padding:16px;margin-bottom:16px;}
      .panel a{color:#9aa6ff;}
      .panel a:visited{color:#9aa6ff;}
    </style>
  </div>
  <main>
    <div class="panel">
      <CsvHeader title={`${genreInfo.name} + Missing from ${genreInfo.name} Tier List`} count={filteredGames.length} csvHref={csvHref} csvName={csvName} />
      <p>Games tagged as {genreInfo.name} that are not in the matching tier list for that genre.</p>
    </div>
    <ThumbnailBorderLegend />
    {filteredGames.length === 0 ? (
      <p>All {genreInfo.name} games are already included in the matching tier list.</p>
    ) : (
      <div class="grid">
        {filteredGames.map((game) => {
          const reviewed = reviewedGameIds.has(game.id);
          const sTier = sTierGameIds.has(game.id);
          return <GameThumbCard game={game} reviewed={reviewed} sTier={sTier} />;
        })}
      </div>
    )}
  </main>
</BaseLayout>
